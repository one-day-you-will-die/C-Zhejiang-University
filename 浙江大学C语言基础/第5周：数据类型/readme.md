# 第五周
# 目录
## 知识点
## 各文件内容
- - - -
## 知识点
* C语言的类型
```
整数： char, short, int, long, ‘long long’
浮点数： float, double, ‘long double’
逻辑： ‘bool’
指针
自定义类型
‘C99类型’
```
* 所表达数的范围： char < short < int < float < double
* 内存中所占据的大小： 1个字节到16个字节
* 内存中表达形式： 二进制数（补码）、编码
* `sizeof`是一个可以给出某个类型或变量在内存中所占据的字节数的`运算符`，如：`sizeof(int)`, `sizeof(i)`
```
sizeof(char) = 1
sizeof(short) = 2
sizeof(int) = 4
sizeof(double) = 8
sizeof(long double) = 16
```
* `sizeof`是静态的，所以`sizeof(a++)`不会对a做任何计算
* `sizeof(a+1.0) = 8`因为`a+1.0`是`double`类型
* int就是用来表达寄存器的，当寄存器为32位时，sizeof(int) = 4
* 利用补码实现正负数，使得-1+1可得出一个溢出的0，且
```
char c = 255;		// 11111111
int i = 255;		// 00000000  00000000  00000000  11111111
unsigned char x = 256 //当作二进制看而非考虑补码
所以 c = -1, i = 255, x = 256
```
* 8进制以0开头，16进制以0x开头。即使赋值时为其他进制，也可用%d输出十进制结果
```
char c = 012;
int i = ox12;
printf("c = %d, i = %d\n", c, i);
printf("c = %o, i = %x\n", c, i);
printf("c = 0%o, i = 0x%x\n", c, i);
>>>c = 10, i = 18
>>>c = 12, i = 12
>>>c = 012, i = 0x12
```
* float 字长 32，有效数字为7；double字长64，有效数字为15
* 足够接近0的数字无法用float和double表示
* `printf`使用`%e`输出科学计数法 
* `printf(“%.3f”, -0.0045);`输出结果为四舍五入后的`-0.005`
* 关于正无穷，负无穷和不存在
```
printf("%f\n", 12.0/0.0);
printf("%f\n", -12.0/0.0);
printf("%f\n", 0.0/0.0);
>>>inf
>>>-inf
>>>nan
```
* 浮点数是没有精度的，所以当 a = 1.1f, b = 2.2f 时, a + b != 3.3
* 所以可利用(a+b) - 3.3的绝对值小于类型最小精度来判断
```
fabs（f1 - f2）< 1e-8
```
* 字符字面量通过单引号输出，如：`‘a’, ‘1’`
* printf和scanf里用%c来输入输出字符
* ASC||码中，`‘a’ - ‘A’`可以得到两段直接的距离，所以
```
a + ‘a’ - ‘A’ 可以把一个大写字母变成小写字母
a + ‘A’ - ‘a’ 可以把一个小写字母变成大写字母
```
* 逃逸字符：
```
\b    回退一格			\"    双引号
\t	    到下一个表格位	\'    单引号
\n    换行				\\    反斜杠本身
\r    回车
```
* 回退一格并不是删除末位一格
* printf会进行自动类型转换，但是scanf需要知道读入的类型
* 强制类型转换常用于转换至较小类型，但要注意，小的变量可能无法表达较大的原始数据。转换方法为`(类型)值`，如`(int)10.2, (short)32`
* 强制转换只会创建一个新的量，而不会对原数据的量和类型做改变
* 使用布尔类型bool，true，false
```
#include <stdbool.h>
```
* 逻辑运算：！逻辑非，&&逻辑与，||逻辑或
* 注意逻辑运算中的短路
```
a == 6 && b = b + 1
对于&&，当左边为false时，右边会被跳过
对于||，左边是true时，右边会被跳过
```

## 各文件内容
`test.c`为习题1答案。